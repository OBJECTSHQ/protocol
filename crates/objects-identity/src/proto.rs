//! Protocol Buffer types for OBJECTS Identity Protocol.
//!
//! This file is @generated by prost-build.
//! To regenerate: `cargo build -p objects-identity --features codegen`

#![allow(dead_code)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Identity {
    /// REQUIRED. Identity identifier. Format: "obj_" + 20 base58 characters.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// REQUIRED. Human-readable handle. 1-30 characters, lowercase alphanumeric,
    /// underscore, and period. Must not start with period or underscore.
    #[prost(string, tag = "2")]
    pub handle: ::prost::alloc::string::String,
    /// REQUIRED. Type of signer that controls this identity.
    #[prost(enumeration = "SignerType", tag = "3")]
    pub signer_type: i32,
    /// REQUIRED. Compressed SEC1 public key of the signer. Exactly 33 bytes.
    #[prost(bytes = "vec", tag = "4")]
    pub signer_public_key: ::prost::alloc::vec::Vec<u8>,
    /// REQUIRED. Random nonce used in ID derivation. Exactly 8 bytes.
    #[prost(bytes = "vec", tag = "5")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// OPTIONAL. Linked Ethereum wallet address for payments.
    /// Format: "0x" + 40 lowercase hex characters.
    #[prost(string, tag = "6")]
    pub wallet_address: ::prost::alloc::string::String,
    /// REQUIRED. Unix timestamp (seconds) when identity was created.
    #[prost(uint64, tag = "7")]
    pub created_at: u64,
    /// REQUIRED. Unix timestamp (seconds) when identity was last updated.
    #[prost(uint64, tag = "8")]
    pub updated_at: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Signature {
    /// REQUIRED. Type of signer that produced this signature.
    #[prost(enumeration = "SignerType", tag = "1")]
    pub signer_type: i32,
    /// REQUIRED. Raw signature bytes.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// CONDITIONAL. Required for passkey signatures.
    #[prost(bytes = "vec", tag = "3")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// CONDITIONAL. Required for wallet signatures.
    #[prost(string, tag = "4")]
    pub address: ::prost::alloc::string::String,
    /// CONDITIONAL. Required for passkey signatures.
    #[prost(bytes = "vec", tag = "5")]
    pub authenticator_data: ::prost::alloc::vec::Vec<u8>,
    /// CONDITIONAL. Required for passkey signatures.
    #[prost(bytes = "vec", tag = "6")]
    pub client_data_json: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateIdentityRequest {
    #[prost(string, tag = "1")]
    pub handle: ::prost::alloc::string::String,
    #[prost(enumeration = "SignerType", tag = "2")]
    pub signer_type: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub signer_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(uint64, tag = "6")]
    pub timestamp: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LinkWalletRequest {
    #[prost(string, tag = "1")]
    pub identity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub wallet_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub identity_signature: ::core::option::Option<Signature>,
    #[prost(message, optional, tag = "4")]
    pub wallet_signature: ::core::option::Option<Signature>,
    #[prost(uint64, tag = "5")]
    pub timestamp: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangeHandleRequest {
    #[prost(string, tag = "1")]
    pub identity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_handle: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(uint64, tag = "4")]
    pub timestamp: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIdentityRequest {
    #[prost(string, tag = "1")]
    pub identity_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveIdentityRequest {
    #[prost(oneof = "resolve_identity_request::Query", tags = "1, 2, 3")]
    pub query: ::core::option::Option<resolve_identity_request::Query>,
}
/// Nested message and enum types in `ResolveIdentityRequest`.
pub mod resolve_identity_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Query {
        #[prost(string, tag = "1")]
        Handle(::prost::alloc::string::String),
        #[prost(bytes, tag = "2")]
        SignerPublicKey(::prost::alloc::vec::Vec<u8>),
        #[prost(string, tag = "3")]
        WalletAddress(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignerType {
    Unspecified = 0,
    Passkey = 1,
    Wallet = 2,
}
impl SignerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNER_TYPE_UNSPECIFIED",
            Self::Passkey => "SIGNER_TYPE_PASSKEY",
            Self::Wallet => "SIGNER_TYPE_WALLET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNER_TYPE_PASSKEY" => Some(Self::Passkey),
            "SIGNER_TYPE_WALLET" => Some(Self::Wallet),
            _ => None,
        }
    }
}
